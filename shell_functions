### Functions
unalias ls 2>/dev/null
unalias -m 'ls*' 2>/dev/null
unfunction ls 2>/dev/null
ls() { 
	local cleaned=()
	for a in "$@"; do
	    [[ "$a" == "-G" ]] && continue        # ignore macOS alias flag
	    cleaned+=("$a")
	  done
	command eza --long --git --icons --group-directories-first --color=auto --classify --header "$@";
}

# alias brew-sync='brew list > ~/github/dotfiles/brew-packages.txt && brew list --cask >> ~/github/dotfiles/brew-packages.txt'
brew-sync() {
	 echo "Syncing Homebrew packages to dotfiles"
	 brew list > ~/github/dotfiles/brew-packages.txt
	 brew list --cask >> ~/github/dotfiles/brew-packages.txt
	 echo "Brew packages saved to ~/github/dotfiles/brew-packages.txt"
}

# Create Environments
make-py-env() {
    if [[ $# -ne 2 ]]; then
        echo "Usage: mkvenv <env_base_name> <python_version (e.g. 3.12.10)>"
        return 1
    fi

    local name=$1
    local version=$2
    local env_name="${name}_${version//./_}"
    local env_path="$HOME/Environments/$env_name"
    local req_path="$HOME/github/dotfiles/requirements/requirements_${env_name}.txt"
    [[ ! -f "$req_path" ]] && req_path="$HOME/github/dotfiles/requirements/requirements_fallback.txt"

    echo "Creating environment: $env_name"
    uv venv "$env_path" --python "$version"

    echo "Created at: $env_path"
    echo "Installing requirements from: $req_path"

    if [[ -f "$req_path" ]]; then
        source "$env_path/bin/activate"
        uv pip install -r "$req_path"
        echo "Done setting up $env_name"
    else
        echo "Requirements file not found: $req_path"
    fi
}

activate-env() {
    echo "Looking for Python environments only in ~/Environments/"
    if [[ -z "$1" ]]; then
        echo "Usage: activate_env <env_name>"
        return 1
    fi
    local env_path="$HOME/Environments/$1/bin/activate"
    if [[ -f "$env_path" ]]; then
        source "$env_path"
        echo "Activated environment: $1"
    else
        echo "Error: No environment found at $env_path"
        return 2
    fi
}

extract() {
    if [[ -f "$1" ]]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1"    ;;
            *.tar.gz)    tar xzf "$1"    ;;
            *.bz2)       bunzip2 "$1"    ;;
            *.rar)       unrar x "$1"    ;;
            *.gz)        gunzip "$1"     ;;
            *.tar)       tar xf "$1"     ;;
            *.tbz2)      tar xjf "$1"    ;;
            *.tgz)       tar xzf "$1"    ;;
            *.zip)       unzip "$1"      ;;
            *.Z)         uncompress "$1" ;;
            *.7z)        7z x "$1"       ;;
            *)           echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

mkcd() {
    mkdir -p "$1" && cd "$1"
}

# clean-dsstore() {
#     # find . -name '.DS_Store' -type f -delete
# 	fd '.DS_Store' -t f -x rm
#     echo "deleted all .DS_Store files."
# }

# clean-dsstore() {
#   # Usage:
#   #   clean-dsstore here # current dir + children
#   #   clean-dsstore user # home + children
#   #   clean-dsstore here/user --dry-run

#   local mode="here"
#   local dry=0

#   while [[ $# -gt 0 ]]; do
#     case "$1" in
#       here|current) mode="here" ;;
#       user|home)    mode="user" ;;
#       --dry-run)    dry=1 ;;
#       -h|--help)    echo "Usage: clean-dsstore [here|user] [--dry-run]"; return 0 ;;
#       *)            echo "Usage: clean-dsstore [here|user] [--dry-run]"; return 2 ;;
#     esac
#     shift
#   done

#   local root
#   [[ "$mode" == "user" ]] && root="$HOME" || root="$PWD"

#   if command -v fd >/dev/null 2>&1; then
#     if (( dry )); then
#       fd -H -uu -t f -g ".DS_Store"   "$root"
#       fd -H -uu -t f -g "._.DS_Store" "$root"
#     else
#       fd -H -uu -t f -g ".DS_Store"   "$root" -X rm -f
#       fd -H -uu -t f -g "._.DS_Store" "$root" -X rm -f
#     fi
#   else
#     if (( dry )); then
#       find "$root" -type f \( -name '.DS_Store' -o -name '._.DS_Store' \) -print
#     else
#       find "$root" -type f \( -name '.DS_Store' -o -name '._.DS_Store' \) -delete
#     fi
#   fi

#   echo "Done: cleaned .DS_Store under $root${dry:+ (dry-run)}"
# }

clean-shop() {
  # Usage:
  #   clean-shop .DS_Store [here|user] [-y|--yes] [--dry-run]
  #   clean-shop __pycache__ [here] [-y|--yes] [--dry-run]

  local target_name="$1"
  shift 

  local mode="here"
  local confirm=0
  local dry=0
  local fd_type=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      here|current) mode="here" ;;
      user|home)    mode="user" ;;
      -y|--yes)     confirm=1 ;;
      --dry-run)    dry=1 ;;
      -h|--help)    echo "Usage: clean-shop <.DS_Store|__pycache__> [here|user] [-y|--yes] [--dry-run]"; return 0 ;;
      *)            echo "Error: Unknown argument '$1'."; return 2 ;;
    esac
    shift
  done

  case "$target_name" in
    .DS_Store)
      fd_type="-t f"
      ;;
    __pycache__)
      fd_type="-t d"
      if [[ "$mode" == "user" ]]; then
        echo "ERROR: Deletion of '$target_name' from the entire system is too risky. I am not taking responsibility for it."
        echo "Please use 'clean-shop $target_name here' to clean the current directory."
        echo "To delete from the entire home directory, run this command in the terminal"
        echo "sudo find ~ -type d -name '__pycache__' -exec rm -rf {} +"
        echo "Good luck! You'll need it."
        return 1
      fi
      ;;
    *)
      echo "Error: Invalid target name '$target_name'. Must be '.DS_Store' or '__pycache__'." # Can erxtend later
      return 2
      ;;
  esac

  local root
  [[ "$mode" == "user" ]] && root="$HOME" || root="$PWD"

  local search_paths
  
  echo "Lookin' for '$target_name' under $root"
  
  if command -v fd >/dev/null 2>&1; then
      if [[ "$target_name" == ".DS_Store" ]]; then
          search_paths=$(fd -H -uu -t f -g ".DS_Store" "$root" && fd -H -uu -t f -g "._.DS_Store" "$root")
      elif [[ "$target_name" == "__pycache__" ]]; then
          search_paths=$(fd -H -uu -t d __pycache__ "$root")
      fi
  else
      if [[ "$target_name" == ".DS_Store" ]]; then
          search_paths=$(find "$root" -type f \( -name '.DS_Store' -o -name '._.DS_Store' \) -print)
      elif [[ "$target_name" == "__pycache__" ]]; then
          search_paths=$(find "$root" -type d -name '__pycache__' -print)
      fi
  fi
  
  if [[ -z "$search_paths" ]]; then
      echo "No '$target_name' objects found to delete under $root."
      return 0
  fi
  
  # This is so much prettier. Will delete when I get bored.
  echo ""
  echo "The following $target_name objects will be deleted:"
  echo "-----------------------------------------------------------------------"
  echo "$search_paths"
  echo "-----------------------------------------------------------------------"
  echo ""

  if (( dry )); then
      local action="dry-run"
  else
      local action="deletion"
      if (( ! confirm )); then
          echo -n "Confirm $action of '$target_name' under '$root'? (y/N): "
          read -r response
          [[ "$response" != [yY] ]] && echo "Action cancelled." && return 0
      fi
  fi
  
  echo "Starting $action of '$target_name' under '$root'..."

  if (( dry )); then
    echo "$search_paths"
  else
    if [[ "$target_name" == ".DS_Store" ]]; then
      if command -v fd >/dev/null 2>&1; then
          fd -H -uu -t f -g ".DS_Store"   "$root" -X rm -f
          fd -H -uu -t f -g "._.DS_Store" "$root" -X rm -f
      else
          find "$root" -type f \( -name '.DS_Store' -o -name '._.DS_Store' \) -delete
      fi

    elif [[ "$target_name" == "__pycache__" ]]; then
      if command -v fd >/dev/null 2>&1; then
          fd -H -uu -t d __pycache__ "$root" -X rm -rf {} +
      else
          find "$root" -type d -name '__pycache__' -exec rm -rf {} +
      fi
    fi
  fi

  echo "Done: processed '$target_name' under $root"
}


myip() {
    curl -s https://ifconfig.me || curl -s https://ipinfo.io/ip
}

get-process-at-port() {
  local port=$1
  local kill=$2
  echo "Process at port $1 is"
  lsof -i :$1
  if (( kill )); then
    echo "Killing process at port $1"
    kill "$(lsof -t -i :$1)"
  fi
}